# Minishell — As beautiful as a shell

**Summary:** This project is about creating a simple shell — your very own little Bash. You will gain extensive knowledge about processes and file descriptors.

**Version:** 9.0

---

## Contents
- [Introduction](#introduction)
- [Common Instructions](#common-instructions)
- [AI Instructions](#ai-instructions)
- [Mandatory Part](#mandatory-part)
- [Bonus Part](#bonus-part)
- [Submission and Peer‑Evaluation](#submission-and-peer-evaluation)

---

## Introduction

Shells have existed since the very beginning of IT. Back then, all developers agreed that communicating with a computer via aligned 1/0 switches was extremely frustrating. It was only logical that they came up with the idea of creating software to communicate with a computer using interactive command lines in a language somewhat close to human language.

With **Minishell**, you’ll travel back in time and experience the challenges developers faced before Windows existed.

---

## Common Instructions

- Your project must be written in **C**.
- Your project must be written in accordance with the **Norm**. If you have bonus files/functions, they are included in the norm check, and you will receive a **0** if there is a norm error.
- Your functions should **not quit unexpectedly** (segmentation fault, bus error, double free, etc.) except for undefined behavior. If this occurs, your project will be considered non‑functional and will receive a **0** during the evaluation.
- **All heap-allocated memory must be properly freed** when necessary. Memory leaks will not be tolerated.
- If the subject requires it, you must submit a **Makefile** that compiles your source files to the required output with the flags `-Wall -Wextra -Werror`, using `cc`. Additionally, your Makefile must **not** perform unnecessary relinking.
- Your Makefile must contain at least the rules: `$(NAME)`, `all`, `clean`, `fclean`, and `re`.
- To submit **bonuses**, include a `bonus` rule in your Makefile, which will add all the various headers, libraries, or functions that are not allowed in the main part of the project. Bonuses must be placed in `_bonus.{c/h}` files, unless the subject specifies otherwise. The evaluation of mandatory and bonus parts is conducted separately.
- If your project allows you to use your **libft**, you must copy its sources and its associated Makefile into a `libft` folder. Your project’s Makefile must compile the library by using its Makefile, then compile the project.
- You are encouraged to **create test programs** for your project, even though this work does not need to be submitted and will not be graded. They will help you test your work (and your peers’) and will be useful during your defense. During defense, you are free to use your tests and/or those of the peer you are evaluating.
- Submit your work to the assigned **Git repository**. Only the work in the Git repository will be graded. If **Deepthought** is assigned to grade your work, it will occur after your peer‑evaluations. If an error happens in any section of your work during Deepthought’s grading, the evaluation will stop.

---

## AI Instructions

### Context
During your learning journey, AI can assist with many different tasks. Explore AI tools and how they can support your work, but always approach them with caution and critically assess the results. Whether it’s code, documentation, ideas, or technical explanations, you can never be completely sure that your question was well‑formed or that the generated content is accurate. Your peers are a valuable resource to help you avoid mistakes and blind spots.

### Main message
- **Use AI** to reduce repetitive or tedious tasks.
- **Develop prompting skills** — both coding and non‑coding — that will benefit your future career.
- **Learn how AI systems work** to better anticipate and avoid common risks, biases, and ethical issues.
- **Continue building technical and power skills** by working with your peers.
- **Only use AI‑generated content** that you fully understand and can take responsibility for.

### Learner rules
- Take time to explore AI tools and understand how they work so you can use them ethically and reduce potential biases.
- Reflect on your problem **before** prompting — this helps you write clearer, more detailed, and more relevant prompts using accurate vocabulary.
- Systematically **check, review, question, and test** anything generated by AI.
- **Always seek peer review** — don’t rely solely on your own validation.

### Phase outcomes
- Develop both general‑purpose and domain‑specific prompting skills.
- Boost productivity with effective use of AI tools.
- Continue strengthening computational thinking, problem‑solving, adaptability, and collaboration.

### Comments and examples
**Good practice:**  
> I ask AI: “How do I test a sorting function?” It gives me a few ideas. I try them out and review the results with a peer. We refine the approach together.

**Bad practice:**  
> I ask AI to write a whole function, copy‑paste it into my project. During peer‑evaluation, I can’t explain what it does or why. I lose credibility — and I fail my project.

**Good practice:**  
> I use AI to help design a parser. Then I walk through the logic with a peer. We catch two bugs and rewrite it together — better, cleaner, and fully understood.

**Bad practice:**  
> I let Copilot generate my code for a key part of my project. It compiles, but I can’t explain how it handles pipes. During the evaluation, I fail to justify and I fail my project.

---

## Mandatory Part

**Program name:** `minishell`  
**Turn‑in files:** `Makefile`, `*.h`, `*.c`  
**Makefile rules:** `NAME`, `all`, `clean`, `fclean`, `re`  
**Arguments:** (as per subject)  
**Libft authorized:** **Yes**  
**Description:** Write a shell.

### Allowed external functions
```
readline, rl_clear_history, rl_on_new_line, rl_replace_line, rl_redisplay, add_history,
printf, malloc, free, write, access, open, read, close, fork, wait, waitpid, wait3, wait4,
signal, sigaction, sigemptyset, sigaddset, kill, exit, getcwd, chdir, stat, lstat, fstat,
unlink, execve, dup, dup2, pipe, opendir, readdir, closedir, strerror, perror, isatty,
ttyname, ttyslot, ioctl, getenv, tcsetattr, tcgetattr, tgetent, tgetflag, tgetnum,
tgetstr, tgoto, tputs
```

### Requirements
- Display a **prompt** when waiting for a new command.
- Have a working **history**.
- **Search and launch** the right executable (based on the `PATH` variable or using a relative/absolute path).
- Use **at most one global variable** to indicate a received signal.  
  - This variable must **only store the signal number**.  
  - It must **not** provide any additional information or access to data.  
  - Using “norm”‑type structures in the global scope is **forbidden**.
- Do **not interpret** unclosed quotes or special characters not required by the subject such as `\` (backslash) or `;` (semicolon).
- Handle quotes:  
  - **Single quotes `'`** prevent the shell from interpreting metacharacters in the quoted sequence.  
  - **Double quotes `"`** prevent interpretation of metacharacters **except** for `$` (dollar sign).
- Implement **redirections**:  
  - `<` redirect input.  
  - `>` redirect output.  
  - `<<` (heredoc): given a delimiter, read input until a line containing the delimiter is seen (**doesn’t need to update history**).  
  - `>>` redirect output in **append** mode.
- Implement **pipes** (`|`): the output of each command in the pipeline is connected to the input of the next command via a pipe.
- Handle **environment variables** (`$` followed by a sequence of characters) which expand to their values.
- Handle **`$?`** which expands to the **exit status** of the most recently executed **foreground pipeline**.
- Handle **Ctrl‑C**, **Ctrl‑D**, and **Ctrl‑\** like in Bash.  
  - In interactive mode:  
    - **Ctrl‑C** displays a new prompt on a new line.  
    - **Ctrl‑D** exits the shell.  
    - **Ctrl‑\** does nothing.
- Implement the following **built‑in commands**:
  - `echo` with option `-n`
  - `cd` with only a relative or absolute path
  - `pwd` with no options
  - `export` with no options
  - `unset` with no options
  - `env` with no options or arguments
  - `exit` with no options

> **Note:** `readline()` may cause memory leaks, but **you are not required to fix them**. This does **not** allow memory leaks in your own code.

> **Scope rule:** Limit yourself to the subject description. Anything not asked is not required. If in doubt about a requirement, **take Bash as a reference**  
> Bash manual: https://www.gnu.org/savannah-checkouts/gnu/bash/manual/

---

## Bonus Part

Your program must implement:
- Logical operators `&&` and `||` with **parentheses** for priorities.
- **Wildcards `*`** should work for the **current working directory**.

> The bonus part will only be evaluated if the **mandatory** part is completed **perfectly** (fully implemented and functioning without issues). If you have not passed **all** the mandatory requirements, **your bonus will not be evaluated**.

---

## Submission and Peer‑Evaluation

- Submit your assignment in your **Git repository** as usual. Only the work **inside** your repository will be evaluated during the defense. Double‑check your file names.
- During the evaluation, a **brief modification** of the project may occasionally be requested (minor behavior change, a few lines of code to write/modify, an easy‑to‑add feature). Be prepared for this step, if mentioned in the evaluation guidelines.
- This step is meant to verify your **actual understanding** of a specific part of the project. The modification can be performed in any development environment you choose and should be feasible within a few minutes — unless a specific timeframe is defined.

Examples of possible requests include: small update to a function or script, modify a display, or adjust a data structure to store new information, etc. The details (scope, target, etc.) will be specified in the evaluation guidelines and may vary from one evaluation to another for the same project.

---

*End of document.*
